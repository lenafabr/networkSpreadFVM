\documentclass[12pt]{article}
\usepackage{url,setspace,amsmath}
\usepackage{graphicx,xcolor}

\usepackage[letterpaper, left=0.9in, right=0.9in, top=0.9in, bottom=0.9in, nofoot, footnotesep=0.15in, headsep=0.15in, footskip=0.25in, nomarginpar]{geometry}

\begin{document}
\title{\vspace{-2cm}Documentation for networkFVMsims: finite volume method implementation of evolving reaction-diffusion fields on a network}
\author{E.~F.~Koslover}
\date{Last updated \today}
\maketitle

The code in this package can be used to simulated dynamics of buffered calcium ions or of other particles spreading across a tubular network. In its default mode, it treats networks as point-like nodes linked by one-dimensional edges of constant radius. Some extensions are provided for inputting 3D meshes of more complicated structures (eg: sheets), but these are not yet documented. Alternately, rapidly-equilibrating `reservoirs' can be included in the networks.

The code stores information about network structure (edge connectivity, edge lengths) in a NETWORK object. Note that while network edges can be curved (and thus longer than the node-to-node distance), the spatial embedding of the edges is not stored. The network structure is input by the user in a .net file (see networktools project on github for Matlab code to manipulate, visualize, and output network structures). The code builds its own MESH structure consisting of linked mesh elements. These can be loaded and visualized with the matlab code provided in scripts.

NOTE: this documentation is far from complete and currently only includes the most basic of the features implemented.
%\tableofcontents
%\newpage

\section{Compilation Instructions}
To compile and run the program, you will need the following:
\begin{itemize}
\item a compiler capable of handling Fortran90.
The code has been tested with the gfortran compiler.
%\item BLAS and LAPACK libraries installed in a place where the compiler knows to look for them
\item Optionally: Matlab to visualize output data
\end{itemize}

The code has been tested on Ubuntu Linux 20.04.

\bigskip\noindent
To compile with gfortran, go into the \path=source= directory. Type \verb=make=.
To compile with any other compiler that can handle Fortran90, type
\begin{verbatim}
make FC=compiler
\end{verbatim}
substituting in the command you usually use to call the compiler.

\noindent
If the compilation works properly, the executable \path=treeParticleSim.exe= will appear in the main directory.

\section{Usage Instructions}
To run the program in the main directory, type:
\begin{verbatim}
./treeparticleSim.exe suffix > stdout.suffix
\end{verbatim}

Here, \verb=suffix= can be any string up to 100 characters in length.
The program reads in all input information from a file named
\path=param.suffix= where \verb=suffix= is the command-line
argument. If no argument is supplied, it will look for a file named
\path=param=. If the desired parameter file does not exist, the
program will exit with an error.
%You can supply multiple suffixes to read in multiple parameter files.

The parameters in the input file are given in the format ``{\em KEYWORD} value" where the possible keywords and values are described
in Section \ref{sec:keywords}. Each keyword goes on a separate
line. Any line that starts with "\#" is treated as a comment and
ignored. Any blank line is also ignored. The keywords in the parameter
file are not case sensitive. For the most part, the order in which the
keywords are given does not matter. All parameters have default
values, so you need only specify keywords and values when you want to
change something from the default.


\section{Example for a Quick Start}


A few example parameter files are provided

The main one is \verb=examples/param.MCFO1=): 
This will run a simulation of particles moving around on a dendritic tree. 
Particles are produced at the soma, move anterograde until they hit a distal tip, then turn around. Switch to the alternate set of TRANSRATE lines in the parameter file to enable the particles to halt and turn around partway.

To run this simulation:

\begin{verbatim}
../treeParticleSim.exe MCFO1
\end{verbatim}

To parse the snapshots for the example and visualize the particle motion, use

\verb=scripts/visualizeExample.m=

A similar simulation on a simple 2-level tree: \verb=examples/param.prodtree=

Another simulation with a fixed number of particles that reflect off all terminal nodes: \verb=examples/param.reftree=

\section{Keyword Index}
\label{sec:keywords}
The code will attempt to read parameters out of a file named \path=param.suffix= where ``suffix'' is the command line argument. If no command line arguments are supplied, it will look for a file named \path=param=. If multiple arguments are supplied, it will read multiple parameter files in sequence.

The parameter file should have one keyword per line and must end with a blank line. All blank lines and all lines beginning with \# are ignored. For the most part, the order of the lines and the capitalization of the keywords does not matter. All keywords except {\em ACTION} are optional. The default values for each parameter are listed below. If a keyword is supplied, then values may or may not be needed as well. Again, the required and optional value types are listed below.

Keywords and multiple values are separated by spaces.

When reading the parameter file, lines longer than 500 characters will be truncated. To continue onto the next line, add ``+++'' at the end of the line to be continued.
No individual keyword or  value should be longer than 100 characters.

Floating point numbers can be formated as $1.0$, $1.1D0$, $10e-1$, $-1.0E+01$, etc., where the exponential notation specifier must be D or E (case insensitive). Integer numbers can also be specified in exponential notation without decimal points (eg: 1000 or 1E3). Logical values can be specified as T, F, TRUE, FALSE, 1, or 0 (with 1 corresponding to true and 0 to false).

\subsection*{List of Keyword inputs}

Some of the below keywords are not actually used in this skeleton code, but are saved for later.

\begin{itemize}
%
\item {\it ABSORBTERM}
\begin{itemize}
	\item value: 1 integer, then several logical values; default: false
	\item 1st num = particle type, then flag for whether each state disappears when hitting a terminal node
\end{itemize}
%
\item {\it ACTION}
  \begin{itemize}
    \item  value: 1 string of at most 20 characters; no default
    \item This keyword sets the overall calculation performed by the program 
    \item Possible values are: RUNSIM
  \end{itemize}
%
\item {\it DELT}
    \begin{itemize}
      \item  value: 1 float; default 1D-4
      \item Time-step for dynamics. 
      \item Not used
    \end{itemize}
%
\item {\it DIRECTEDTREE}
\begin{itemize}
	\item 1 logical or nothing; default false
	\item If no value provided, flip to true
	\item Set up network as a directed tree, placing parent edge first in NODEEDGES and then ordering by edge ID
	\item Will raise error if edges are not properly directed
\end{itemize}
%
\item {\it INITEDGES}
\begin{itemize}
	\item value: 1 or more integers; default = -1
	\item List of edges such that particles start uniformly distributed over those edges
	\item If first number is negative, start particles uniformly over all edges in the network
\end{itemize}
%
\item {\it INITSTATE}
\begin{itemize}
	\item value: integer, then 1 or more floats; default: 1 1D0
	\item Distribution of starting states
	\item first value: particle type
	\item float values: probability of starting in each state
\end{itemize}
\item {\it NETWORKDIM}
	\begin{itemize}
		\item  value: 1 integer; default: 3
		\item Dimensionality of space in which network is embedded
	\end{itemize}
%
\item {\it NETFILE}
\begin{itemize}
	\item  value: 1 string; default: *.net
	\item Input network file (full format with NODE lines, etc) used to start the simulation
	 \item Any * in the file name will be replaced by the command-line argument (suffix)
\end{itemize}
%
\item {\it NPARTINIT}
\begin{itemize}
	\item  value: 1 integer; default: 1
	\item Number of initial particles to place in the system
\end{itemize}
%
\item {\it OUTFILE}
    \begin{itemize}
      \item  value: 1 string, up to 100 characters; default: *.out
      \item Output file for {\color{red} something} (not sure what yet)
      \item Any * in the file name will be replaced by the command-line argument (suffix)
      \item Not used
      \end{itemize}
%
\item {\it PRINTEVERY}
\begin{itemize}
	\item  value: 1 integer; default: 1
	\item Print to screen every so many steps
\end{itemize}
%
\item {\it PRODUCTION}
\begin{itemize}
	\item  value: 2 integers, float, 1 or more integers; default: 1 1 0D0 1
	\item Control production of new particles at nodes
	\item First number: particle type, second number: state that new particles are produced in
	\item 3rd number: production rate
	\item remaining number: list of nodes where particles are produced
\end{itemize}
%
\item {\it READEDGEVALS}
\begin{itemize}
	\item values: nothing or 1 logical; default=false
	\item if no value provided, switch to true
	\item Read in one additional floating point value for each edge from network file
\end{itemize}
%
\item {\it READNODEVALS}
\begin{itemize}
	\item values: nothing or 1 logical; default=false
	\item if no value provided, switch to true
	\item Read in one additional floating point value for each node from network file
\end{itemize}
%
\item {\it RNGSEED}
  \begin{itemize}
    \item 1 integer; default: 0
    \item seed for random number generator
    \item value of 0 will seed with system time in milliseconds
    \item value of -1 will use the last 5 characters in the suffix
    \item value of -2 will use the last 4 charactes in the suffix and the millisecond time
    \item other positive value: the seed is used directly for repeatable simulations (should be positive)
  \end{itemize}
%
\item {\it RUNSPEED}
\begin{itemize}
	\item  value: 1 or more floats; default 0D0
	\item Not used
\end{itemize}
%
\item {\it SNAPSHOTFILE}
    \begin{itemize}
      \item  value: 1 string; default: *.snap.out
      \item File for dumping out snapshots. Can also be specified within SNAPSHOTS keyword.
    \end{itemize}
%
\item {\it SNAPSHOTS}
\begin{itemize}
	\item 1 optional integer, 1 optional string, 1 optional logical; defaults: 1, *.snap.out, false
	\item Dump snapshots over the course of the calculation
	\item integer: how often to dump snapshots; string: snapshot file (* is replaced with suffix); logical: append rather than rewriting the snapshot file
	\item Snapshot file contains multiple snapshots of network structure and other info. Should be read with \verb=parseDynNetworkSnapshots.m= script
\end{itemize}
%
\item {\it SPLITTYPE}
\begin{itemize}
	\item value: 2 integer, string of up to 30 characters
	\item Default: \verb=EQUAL_OTHER=
	\item numbers are particle type, state. Then a string describing how to split among branches when passing a junction, for each state
	\item Allowed values: 
	\begin{itemize}
		\item \verb=EQUAL_OTHER=: equally likely to step on all edges other than the one it starts on
		\item \verb=DOWNSTREAM_EDGEVALS=: when moving downstream, split among daughter edges in proportion to edgevals. DIRECTEDTREE must be set
		\item \verb=UPSTREAM_EDGEVALS=: when moving upstream, go into trunk. DIRECTEDTREE must be set
	\end{itemize}
\end{itemize}

\item {\it TRANSRATES}
\begin{itemize}
	\item value: 2 integers, then several positive floats; default: 0
	\item 1st num = particle type, 2nd num = output state, floats = rates of transitioning from all other states to this output state
\end{itemize}
\item {\it TRANSTERM}
\begin{itemize}
	\item value: 2 integers, then several positive floats; default: 0
	\item 1st num = particle type, 2nd num = output state, floats = probability of switching from all other states into this output state when hitting a dead end node
\end{itemize}
%
\item {\it VELOCITY}
\begin{itemize}
	\item  value: integer, then (nstate) floats; default: 0D0
	\item For a given type of particle (first number), list the velocity in each state
\end{itemize}
\item {\it VERBOSE}
        \begin{itemize}
          \item  value: 1 logical; default: false
          \item Print extra output. Not currently implemented
        \end{itemize}
% --------------------------

\end{itemize}

%\bibliographystyle{aip}
%\bibliography{fiberModel}

\end{document}
